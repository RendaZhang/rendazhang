import { readdir, readFile, writeFile, rm } from 'node:fs/promises';
import path from 'node:path';
import logger from '../src/utils/logger';

type GenerateResult = { hasTs: boolean };

const ROOT = path.resolve('src');
const TS_FILE_EXTS = new Set(['.ts', '.tsx']);
const TEST_DIR = '__tests__';
const TEST_FILE_RE = /\.(test|spec)\.tsx?$/;
const DECL_FILE_RE = /\.d\.ts$/;

const AUTO_HEADER = '// AUTO-GENERATED by scripts/generateIndex.ts — DO NOT EDIT.\n';

const SRC_PREFIX = 'src/';

function pathForLog(absPath: string): string {
  // 计算相对 ROOT 的路径，并统一为正斜杠
  const rel = path.relative(ROOT, absPath);
  const normalized = rel.split(path.sep).join('/');
  return `${SRC_PREFIX}${normalized}`;
}

function toCamelBase(name: string): string {
  const base = path.parse(name).name;
  return base.replace(/[-_]+(\w)/g, (_, c: string) => c.toUpperCase());
}

const RESERVED = new Set([
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'debugger',
  'default',
  'delete',
  'do',
  'else',
  'export',
  'extends',
  'finally',
  'for',
  'function',
  'if',
  'import',
  'in',
  'instanceof',
  'new',
  'return',
  'super',
  'switch',
  'this',
  'throw',
  'try',
  'typeof',
  'var',
  'void',
  'while',
  'with',
  'yield',
  'let',
  'enum',
  'await',
  'implements',
  'package',
  'protected',
  'interface',
  'private',
  'public',
  'null',
  'true',
  'false'
]);

function makeValidIdentifier(raw: string): string {
  let s = raw.replace(/[^A-Za-z0-9_$]/g, '');
  if (!/^[A-Za-z_$]/.test(s)) s = '_' + s;
  if (s.length === 0) s = '_';
  if (RESERVED.has(s)) s = '_' + s;
  return s;
}

async function isModuleFile(absPath: string): Promise<{ isModule: boolean; hasDefault: boolean }> {
  try {
    const txt = await readFile(absPath, 'utf8');
    // 排除 export =
    const hasExportEq = /^\s*export\s*=/m.test(txt);
    // 认一切非 "export =" 的导出（含 async/declare 等）
    const hasAnyExport = /^\s*export\b(?!\s*=)/m.test(txt);
    // 默认导出
    const hasDefault = /^\s*export\s+default\b/m.test(txt);
    return { isModule: hasAnyExport && !hasExportEq, hasDefault };
  } catch {
    return { isModule: false, hasDefault: false };
  }
}

async function generate(dir: string): Promise<GenerateResult> {
  const entries = await readdir(dir, { withFileTypes: true });
  const dirs: string[] = [];
  const tsFiles: string[] = [];
  let hasIndexTs = false;

  for (const entry of entries) {
    if (entry.isDirectory()) {
      if (entry.name === TEST_DIR) continue;
      dirs.push(entry.name);
    } else if (entry.isFile()) {
      if (/^index\.(ts|tsx)$/.test(entry.name)) {
        // 识别 index.tsx
        hasIndexTs = true;
        continue;
      }
      const ext = path.extname(entry.name);
      if (!TS_FILE_EXTS.has(ext)) continue;
      if (DECL_FILE_RE.test(entry.name)) continue; // 跳过 .d.ts
      if (TEST_FILE_RE.test(entry.name)) continue; // 跳过 test/spec
      tsFiles.push(entry.name);
    }
  }

  dirs.sort();
  tsFiles.sort();

  const subResults: Array<[string, GenerateResult]> = [];
  for (const d of dirs) {
    const res = await generate(path.join(dir, d));
    subResults.push([d, res]);
  }

  const hasTs = hasIndexTs || tsFiles.length > 0 || subResults.some(([, r]) => r.hasTs);

  const lines: string[] = [];

  // 子目录：只导出真正含 TS 的目录
  for (const [d, r] of subResults) {
    if (r.hasTs) lines.push(`export * from './${d}';`);
  }

  // 当前目录文件
  for (const f of tsFiles) {
    const abs = path.join(dir, f);
    const relNoExt = './' + path.basename(f, path.extname(f));
    const { isModule, hasDefault } = await isModuleFile(abs);
    if (!isModule) continue;

    lines.push(`export * from '${relNoExt}';`);
    if (hasDefault) {
      const alias = makeValidIdentifier(toCamelBase(f)); // 合法化别名
      lines.push(`export { default as ${alias} } from '${relNoExt}';`);
    }
  }

  const indexPath = path.join(dir, 'index.ts');

  if (lines.length > 0) {
    const newContent = AUTO_HEADER + lines.join('\n') + '\n';
    let shouldWrite = true;

    try {
      const old = await readFile(indexPath, 'utf8');
      if (!old.startsWith(AUTO_HEADER)) {
        // 有手写 index.ts：不覆盖
        logger.warn(`[generate-index] Skip overwrite (manual): ${pathForLog(indexPath)}`);
        shouldWrite = false;
      } else if (old === newContent) {
        shouldWrite = false;
      }
    } catch {
      logger.warn(`[generate-index] file not exist: ${pathForLog(indexPath)}`);
    }

    if (shouldWrite) {
      await writeFile(indexPath, newContent, 'utf8');
      logger.log(`[generate-index] Wrote ${pathForLog(indexPath)}`);
    }
    return { hasTs: true };
  } else {
    // 仅删除“带签名”的 index.ts；手写 index.ts 永不删除
    try {
      const old = await readFile(indexPath, 'utf8');
      if (old.startsWith(AUTO_HEADER)) {
        await rm(indexPath);
        logger.log(`[generate-index] Removed ${pathForLog(indexPath)}`);
      } else {
        logger.warn(`[generate-index] Keep manual index (empty dir): ${pathForLog(indexPath)}`);
      }
    } catch {
      /* nothing to remove */
    }
    return { hasTs };
  }
}

await generate(ROOT);
